/*
 * SPDX-FileCopyrightText: 2016-2019 Emanuele Vespa
 * SPDX-FileCopyrightText: 2018-2021 Smart Robotics Lab, Imperial College London, Technical University of Munich
 * SPDX-FileCopyrightText: 2019-2021 Nils Funk
 * SPDX-FileCopyrightText: 2020-2021 Sotiris Papatheodorou
 * SPDX-License-Identifier: BSD-3-Clause
 */

#ifndef SE_MESHING_IO_IMPL_HPP
#define SE_MESHING_IO_IMPL_HPP

namespace se {
namespace io {

template<typename FaceT>
int save_mesh(const Mesh<FaceT>& mesh_M, const std::string& filename, const Eigen::Affine3f& T_OM)
{
    if (str_utils::ends_with(filename, ".ply")) {
        return save_mesh_ply(mesh_M, filename, T_OM);
    }
    else if (str_utils::ends_with(filename, ".vtk")) {
        return save_mesh_vtk(mesh_M, filename, T_OM);
    }
    else if (str_utils::ends_with(filename, ".obj")) {
        return save_mesh_obj(mesh_M, filename, T_OM);
    }
    else {
        throw std::invalid_argument("unknown file extension: " + filename);
    }
}

template<typename FaceT>
int save_mesh_vtk(const Mesh<FaceT>& mesh_M,
                  const std::string& filename,
                  const Eigen::Affine3f& T_OM)
{
    // Open the file for writing.
    std::ofstream file(filename.c_str());
    if (!file.is_open()) {
        std::cerr << "Error writing mesh file " << filename << "\n";
        return 1;
    }

    const size_t num_faces = mesh_M.size();
    const size_t num_vertices = FaceT::num_vertexes * num_faces;

    // Write the header.
    file << "# vtk DataFile Version 3.0\n";
    file << "Mesh generated by supereight 2\n";
    file << "ASCII\n";
    file << "DATASET POLYDATA\n\n";

    // Write the vertices.
    file << "POINTS " << num_vertices << " float\n";
    for (const auto& face : mesh_M) {
        for (const auto& vertex_M : face.vertexes) {
            const Eigen::Vector3f vertex_W = T_OM * vertex_M;
            file << vertex_W.x() << " " << vertex_W.y() << " " << vertex_W.z() << "\n";
        }
    }
    file << "\n";

    // Write the faces.
    file << "POLYGONS " << num_faces << " " << num_faces * (1 + FaceT::num_vertexes) << "\n";
    for (size_t f = 0; f < num_faces; ++f) {
        file << FaceT::num_vertexes;
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            file << " " << FaceT::num_vertexes * f + v;
        }
        file << "\n";
    }
    file << "\n";

    file << "CELL_DATA " << num_faces << "\n\n";

    // Write the face scale.
    file << "SCALARS scale unsigned_char\n";
    file << "LOOKUP_TABLE default\n";
    for (const auto& face : mesh_M) {
        file << static_cast<int>(face.max_vertex_scale) << "\n";
    }

    // Write the face scale colours.
    file << "COLOR_SCALARS scale_colour 3\n";
    for (const auto& face : mesh_M) {
        const Eigen::Vector3f rgb = scale_colour(face.max_vertex_scale) / 255.0f;
        file << rgb.x() << " " << rgb.y() << " " << rgb.z() << "\n";
    }
    file << "\n";

    file.close();
    return 0;
}



template<typename FaceT>
int save_mesh_ply(const Mesh<FaceT>& mesh_M,
                  const std::string& filename,
                  const Eigen::Affine3f& T_OM)
{
    // Open the file for writing.
    std::ofstream file(filename.c_str());
    if (!file.is_open()) {
        std::cerr << "Error writing mesh file " << filename << "\n";
        return 1;
    }

    const size_t num_faces = mesh_M.size();
    const size_t num_vertices = FaceT::num_vertexes * num_faces;

    // Write header
    file << "ply\n";
    file << "format ascii 1.0\n";
    file << "comment Mesh generated by supereight 2\n";
    file << "element vertex " << num_vertices << "\n";
    file << "property float x\n";
    file << "property float y\n";
    file << "property float z\n";
    file << "element face " << num_faces << "\n";
    file << "property list uchar int vertex_index\n";
    file << "property uchar red\n";
    file << "property uchar green\n";
    file << "property uchar blue\n";
    file << "end_header\n";

    // Write the vertices.
    for (const auto& face : mesh_M) {
        for (const auto& vertex_M : face.vertexes) {
            const Eigen::Vector3f vertex_W = T_OM * vertex_M;
            file << vertex_W.x() << " " << vertex_W.y() << " " << vertex_W.z() << "\n";
        }
    }

    // Write the faces.
    for (size_t f = 0; f < num_faces; ++f) {
        file << FaceT::num_vertexes;
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            file << " " << FaceT::num_vertexes * f + v;
        }
        // Write the face scale colour.
        const Eigen::Vector3i rgb = scale_colour(mesh_M[f].max_vertex_scale).template cast<int>();
        file << " " << rgb.x() << " " << rgb.y() << " " << rgb.z() << "\n";
    }

    file.close();
    return 0;
}



template<typename FaceT>
int save_mesh_obj(const Mesh<FaceT>& mesh_M,
                  const std::string& filename,
                  const Eigen::Affine3f& T_OM)
{
    // Open the file for writing.
    std::ofstream file(filename.c_str());
    if (!file.is_open()) {
        std::cerr << "Error writing mesh file " << filename << "\n";
        return 1;
    }

    const size_t num_faces = mesh_M.size();
    const size_t num_vertices = FaceT::num_vertexes * num_faces;

    // Write the header.
    file << "# Mesh generated by supereight 2\n";
    file << "# " << num_vertices << " vertices\n";
    file << "# " << num_faces << " faces\n";

    // Write the vertices.
    for (const auto& face : mesh_M) {
        for (const auto& vertex_M : face.vertexes) {
            const Eigen::Vector3f vertex_W = T_OM * vertex_M;
            file << "v " << vertex_W.x() << " " << vertex_W.y() << " " << vertex_W.z() << "\n";
        }
    }

    // Write the faces.
    for (size_t f = 0; f < num_faces; ++f) {
        file << "f";
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            file << " " << FaceT::num_vertexes * f + v + 1;
        }
        file << "\n";
    }

    file.close();
    return 0;
}

} // namespace io
} // namespace se

#endif // SE_MESHING_IO_IMPL_HPP
